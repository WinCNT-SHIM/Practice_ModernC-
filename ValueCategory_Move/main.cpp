#include <iostream>
#include <string>
#include <vector>
using namespace std;

/// <summary>
/// 예)
/// b = a;
/// 일반적인 경우라면 a의 값이 b에 복사될 것이다
/// 하지만 a의 메모리가 크면 클수록 복사 연산이 커질 것이다
/// (복사 연산도 느린 편에 속한다)
/// 그래서 만약 a가 다시 사용할 것이 아니라면
/// 복사가 아닌 "이동"을 사용하면 연산 속도가 빨라질 것이다
/// ()
/// 
/// 
/// 
/// 전제1. 다시 사용할 
/// 전제2. 
/// 
/// 임시 변수, 상수 등은 어차피 사라질 것이므로 이동을 시키는 것이 좋다
/// 
/// </summary>
/// <returns></returns>
int main()
{
	// 1 + 2는 임시 변수(3)이 생긴다
	int temp = 1 + 2 + 3;


	// ==================== 예제 ====================
	int a = 0;
	int& b = a;		// Lvalue 참조
	int&& c = 0;	// Rvalue 참조, 임시 값이므로 컴파일러가 자동으로 이동해준다

	const int& d1 = 0;
	const int& d2 = a;
	//d2 = b;				// error


	// ==================== move 함수와 Xvalue ====================
	//int&& d = a;			// Lvalue는 대입 연산자로 이동시킬 수 없다
	// C++11에서는 move() 함수를 지원해서 Lvalue도 이동시킬 수 있게 되었다
	// move(a)의 경우, 주소는 가지고 있지만 이동을 할 수 있는 Xvalue로 만든다
	int&& d = move(a);

	// 단, move() 함수는 정확히는 캐스팅만 해주는 것이고
	// 실제 복사, 이동은 당연히 =(대입 연산자)에서 일어난다
	// 즉, 클래스 객체의 이동을 제대로 하기 위해서는 이동 생성자도 구현해야 한다
}